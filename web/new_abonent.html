<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">

  <!-- JKH CANON FIX: suppress false "Guest: read-only" dialogs for logged-in users (must run BEFORE data.js) -->
  <script>
    (function(){
      function jkhSafeParse(s){ try { return JSON.parse(s); } catch(e){ return null; } }
      function jkhHasValidSession(){
        try{
          var sess = jkhSafeParse(localStorage.getItem("auth_session_v1") || "null");
          if(!sess || !sess.userId) return false;
          if(sess.expiresAt && Date.now() > sess.expiresAt) return false;
          var users = jkhSafeParse(localStorage.getItem("auth_users_v1") || "[]");
          if(!Array.isArray(users)) return false;
          for(var i=0;i<users.length;i++){
            var u = users[i] || {};
            if(u.id === sess.userId) return true;
          }
          return false;
        }catch(e){ return false; }
      }
      if(!jkhHasValidSession()) return;

      var BLOCK = [
        "Гость: только просмотр. Войдите, чтобы сохранять.",
        "Гость: только просмотр",
        "только просмотр"
      ];
      function shouldBlock(msg){
        msg = String(msg || "");
        for(var i=0;i<BLOCK.length;i++){
          if(msg.indexOf(BLOCK[i]) !== -1) return true;
        }
        return false;
      }

      var _alert = window.alert;
      var _confirm = window.confirm;

      window.alert = function(msg){
        if(shouldBlock(msg)) return;
        return _alert.call(window, msg);
      };
      window.confirm = function(msg){
        if(shouldBlock(msg)) return true;
        return _confirm.call(window, msg);
      };
    })();
  </script>

  <script src="critical_guard.js" defer></script>
  <title>Новый абонент</title>
  <link rel="stylesheet" href="style.css">

  <!-- ✅ CRITICAL: auth + storage ДО data.js -->
  <script src="auth.js"></script>
  <script src="storage.js"></script>

  <!-- ОБЯЗАТЕЛЬНО подключаем базу ДО layout.js -->
  <script src="data.js"></script>
  <script src="layout.js"></script>

  <!-- ✅ Variant A: движок авто-начислений (без UI изменений) -->
  <script src="autoaccrual_engine.js"></script>
  <!-- ✅ нужен для расчёта долга при передаче -->
  <script src="calc_engine.js"></script>

  <style>
    .form-block {
      max-width: 520px;
      border: 2px solid #000;
      padding: 14px;
      background: #fff;
    }
    .form-block label { display:block; margin-top: 10px; font-size: 13px; }
    .form-block input, .form-block textarea, .form-block select {
      width: 100%;
      border: 2px solid #000;
      padding: 6px 8px;
      box-sizing: border-box;
      font-size: 13px;
      font-family: inherit;
    }
    .form-block input { height: 30px; }
    textarea{ min-height: 90px; resize: vertical; }

    .row2 {
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px 12px;
    }
    .muted {
      font-size: 12px;
      opacity: 0.85;
      margin-top: 6px;
      line-height: 1.35;
    }
    .btn-wide { width: 100%; margin-top: 14px; }

    .readonly-box{
      border: 2px solid #000;
      padding: 10px;
      margin-top: 10px;
      font-size: 13px;
      background:#fff;
    }
    .readonly-box .title{
      font-weight: bold;
      margin-bottom: 6px;
    }
    .readonly-row{ margin-top: 4px; }

    .top-actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin: 10px 0 14px;
    }
    .btn{
      border:2px solid #000;
      background:#e5e5e5;
      padding:6px 12px;
      cursor:pointer;
      font-size:13px;
    }
    .btn:disabled{ opacity:.6; cursor:default; }

    /* ===== список абонентов снизу ===== */
    .list-panel{
      margin-top: 18px;
      border: 2px solid #000;
      padding: 12px;
      background: #fff;
    }
    .list-panel .head{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    .list-panel .title{
      font-weight: 700;
      font-size: 16px;
    }
    .list-panel .sub{
      font-size: 12px;
      opacity: .85;
    }
    .count{
      font-size: 12px;
      opacity: .85;
    }

    #abonentsTable{
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
      font-size: 13px;
    }
    #abonentsTable th, #abonentsTable td{
      border: 2px solid #000;
      padding: 6px;
      vertical-align: top;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    #abonentsTable thead th{
      background: #f2f2f2;
      font-weight: 700;
    }
    #abonentsTable .filters th{
      background: #fff;
      padding: 4px;
    }
    .col-ls{ width: 90px; }
    .col-fio{ width: 260px; }
    .col-addr{ width: 360px; }
    .col-start{ width: 180px; }
    .col-period{ width: 230px; }
    .col-open{ width: 90px; }

    .filter-input{
      width: 100%;
      border: 2px solid #000;
      height: 26px;
      padding: 2px 6px;
      box-sizing: border-box;
      font-size: 12px;
      font-family: inherit;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .open-link{
      text-decoration: underline;
      cursor: pointer;
      white-space: nowrap;
    }
    .period-active{ font-weight: 700; }
    .period-ended{ color:#b00; font-weight:700; }
  </style>
</head>
<body>
<script>renderLayout();</script>

<h2>Создать нового абонента</h2>

<div class="top-actions" id="topActions" style="display:none;">
  <button class="btn" type="button" id="btnBackToImport">← Вернуться к импорту</button>
</div>

<div class="form-block">

  <div class="row2">
    <div>
      <label>Фамилия</label>
      <input id="na_last" type="text" autocomplete="family-name">
    </div>
    <div>
      <label>Имя</label>
      <input id="na_first" type="text" autocomplete="given-name">
    </div>
  </div>

  <label>Отчество</label>
  <input id="na_mid" type="text">

  <label>Лицевой счёт</label>
  <input id="na_ls" type="text" inputmode="numeric" placeholder="например: 0105">

  <div class="row2">
    <div>
      <label>Дата начала расчёта (с какого дня месяца начать начислять)</label>
      <input id="na_date_from" type="date">
      <div class="muted">Если оставить пустым — поставим 1-е число текущего месяца. Эта дата также используется как старт периода ответственности при передаче квартиры.</div>
    </div>
    <div></div>
  </div>

  <div class="row2">
    <div>
      <label>Телефон</label>
      <input id="na_phone" type="text" autocomplete="tel">
    </div>
    <div>
      <label>E-mail</label>
      <input id="na_email" type="email" autocomplete="email" placeholder="например: example@mail.ru">
    </div>
  </div>

  <label>Примечание об абоненте</label>
  <textarea id="na_note" placeholder="Примечание..."></textarea>

  <div id="importPrefillBox" class="readonly-box" style="display:none;">
    <div class="title">Данные из Excel (предзаполнение)</div>
    <div class="readonly-row" id="importPrefillText"></div>
    <div class="muted">
      Выберите квартиру (адрес) ниже и нажмите «СОЗДАТЬ АБОНЕНТА».
      После создания вы вернётесь на импорт, и строка перепроверится (UID подтянется из базы).
    </div>
  </div>

  <div class="row">
    <div class="col">
      <label for="premiseSelect">Выбрать квартиру</label>
      <select id="premiseSelect">
        <option value="">— выберите квартиру —</option>
      </select>
      <div class="muted">
        Если нужной квартиры нет в списке — добавьте её в разделе «Квартиры» (premises.html), затем вернитесь сюда.
      </div>
    </div>
  </div>

  <!-- скрытые поля привязки -->
  <input id="na_regnum" type="hidden">
  <input id="na_city" type="hidden">
  <input id="na_street" type="hidden">
  <input id="na_house" type="hidden">
  <input id="na_flat" type="hidden">
  <input id="na_square" type="hidden">

  <!-- из Excel -->
  <input id="na_square_excel" type="hidden">
  <input id="na_uid_import" type="hidden">

  <!-- откуда пришли -->
  <input id="na_src" type="hidden">
  <input id="na_return" type="hidden">

  <div id="premiseInfo" class="readonly-box" style="display:none;">
    <div class="title">Квартира (привязка автоматически)</div>
    <div class="readonly-row" id="premiseAddr"></div>
    <div class="muted">
      Связь с квартирой сохраняется через regnum + адресные поля из premises.
    </div>
  </div>

  <!-- Блок передачи квартиры -->
  <div id="debtTransferBox" class="readonly-box" style="display:none; border-color:#c77b00;">
    <div class="title">Квартира уже занята — передача</div>

    <div class="readonly-row" id="debtTransferInfo"></div>

    <div class="readonly-row" style="margin-top:6px;">
      <b>Новый период ответственности с:</b> <span id="transferStartPreview" class="mono">—</span>
    </div>
    <div class="readonly-row">
      <b>Старый период закроется по:</b> <span id="transferEndPreview" class="mono">—</span>
    </div>

    <div class="readonly-row" style="margin-top:8px;">
      <b>Долг нового абонента на старте:</b> <span id="newDebtStart" class="mono">0.00</span>
    </div>

    <!-- ВАЖНО: по ТЗ/канону — по умолчанию долг НЕ переносим, у нового старт 0 -->
    <label style="margin-top:10px; display:block;">
      <input type="checkbox" id="na_transfer_debt">
      Передать долг новому абоненту (иначе у нового 0, у старого остаётся последний долг)
    </label>

    <div class="muted" style="margin-top:8px;">
      Эта кнопка делает “правильную передачу”:
      закрывает период старого абонента, ставит новому период с выбранной даты, фиксирует долг старого, и создаёт нового абонента.
    </div>

    <button class="btn" type="button" id="btnTransferAndCreate" style="margin-top:10px; width:100%;">
      ПЕРЕДАТЬ КВАРТИРУ (закрыть старого) и СОЗДАТЬ АБОНЕНТА
    </button>
  </div>

  <div id="premiseWarn" class="readonly-box" style="display:none; border-color:#b00;">
    <div class="title">Не выбрана квартира</div>
    <div class="muted">
      Выберите квартиру из списка выше.
      Если нужной квартиры нет — добавьте её в «Квартиры» (premises.html).
    </div>
  </div>

  <button class="btn btn-wide" id="btnCreate">СОЗДАТЬ АБОНЕНТА</button>

</div>

<!-- ====== НИЖЕ: список всех абонентов + поиск по столбцам ====== -->
<div class="list-panel">
  <div class="head">
    <div>
      <div class="title">Список всех абонентов</div>
      <div class="sub">Фильтры работают по каждому столбцу. Клик “открыть” — переход в карточку.</div>
    </div>
    <div class="count" id="abonentsCount">—</div>
  </div>

  <table id="abonentsTable">
    <colgroup>
      <col class="col-ls">
      <col class="col-fio">
      <col class="col-addr">
      <col class="col-start">
      <col class="col-period">
      <col class="col-open">
    </colgroup>
    <thead>
      <tr>
        <th>ЛС</th>
        <th>ФИО</th>
        <th>Адрес</th>
        <th>Дата начала расчёта</th>
        <th>Период ответственности (этот абонент)</th>
        <th></th>
      </tr>
      <tr class="filters">
        <th><input class="filter-input" data-col="ls" placeholder="поиск..."></th>
        <th><input class="filter-input" data-col="fio" placeholder="поиск..."></th>
        <th><input class="filter-input" data-col="addr" placeholder="поиск..."></th>
        <th><input class="filter-input" data-col="start" placeholder="YYYY-MM-DD / поиск..."></th>
        <th><input class="filter-input" data-col="period" placeholder="поиск..."></th>
        <th><button class="btn" type="button" id="btnFiltersReset" style="padding:4px 8px; font-size:12px;">сброс</button></th>
      </tr>
    </thead>
    <tbody id="abonentsTbody"></tbody>
  </table>
</div>

<script>
/* =========================
   УТИЛИТЫ
   ========================= */
function joinFio(last, first, mid) {
  return [last, first, mid].map(x => String(x || "").trim()).filter(Boolean).join(" ");
}

function generateUid() {
  return "uid_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2, 8);
}

function getDefaultCalcStartDate(){
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,'0');
  return `${yyyy}-${mm}-01`;
}

function normalizeLs4(v){
  const s = String(v || "").trim().replace(/\s+/g,'');
  if (!s) return "";
  const digits = s.replace(/\D+/g,'');
  if (!digits) return "";
  if (digits.length >= 4) return digits.slice(-4);
  return digits.padStart(4, "0");
}

function getNextLsId(preferred) {
  const db = window.AbonentsDB?.abonents || {};
  const p = normalizeLs4(preferred);
  if (p && !db[p]) return p;

  let n = 1;
  const ids = Object.keys(db).map(x => parseInt(x, 10)).filter(x => Number.isFinite(x));
  if (ids.length) n = Math.max(...ids) + 1;

  while (db[String(String(n).padStart(4,'0'))]) n++;
  return String(n).padStart(4,'0');
}

function esc(s){
  return String(s ?? '')
    .replaceAll("&","&amp;").replaceAll("<","&lt;")
    .replaceAll(">","&gt;").replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

/* =========================
   ДАТЫ / ПЕРИОДЫ
   ========================= */
function toIsoDate(d){
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${dd}`;
}
function getTodayIso(){ return toIsoDate(new Date()); }
function getYesterdayIso(iso){
  const s = String(iso || '').trim();
  const d = s ? new Date(s + 'T00:00:00') : new Date();
  if (!Number.isFinite(d.getTime())) return getTodayIso();
  d.setDate(d.getDate()-1);
  return toIsoDate(d);
}

/* =========================
   КВАРТИРЫ (premises)
   ========================= */
function formatPremiseOption(regnum, p) {
  const city = String(p?.city || "").trim();
  const street = String(p?.street || "").trim();
  const house = String(p?.house || "").trim();
  const flat = String(p?.flat || "").trim();
  const sq = (p?.square === undefined || p?.square === null || p?.square === "") ? "" : String(p.square).trim();

  const addr = [city, street, house, flat].filter(Boolean).join(", ");
  const sqTxt = sq ? (" (" + sq + " м²)") : "";
  return (String(regnum || "").trim() || "—") + " — " + (addr || "адрес не заполнен") + sqTxt;
}

function populatePremiseSelect(selectedRegnum) {
  const sel = document.getElementById("premiseSelect");
  if (!sel) return;

  while (sel.options.length > 1) sel.remove(1);

  const premises = window.AbonentsDB?.premises || {};
  const regs = Object.keys(premises);

  regs.sort((a, b) => {
    const pa = premises[a] || {};
    const pb = premises[b] || {};
    const aa = [pa.city, pa.street, pa.house, pa.flat].map(x => String(x || "").toLowerCase()).join("|");
    const bb = [pb.city, pb.street, pb.house, pb.flat].map(x => String(x || "").toLowerCase()).join("|");
    if (aa < bb) return -1;
    if (aa > bb) return 1;
    return String(a).localeCompare(String(b), "ru");
  });

  regs.forEach(reg => {
    const p = premises[reg] || {};
    const opt = document.createElement("option");
    opt.value = String(reg);
    opt.textContent = formatPremiseOption(reg, p);
    sel.appendChild(opt);
  });

  if (selectedRegnum) sel.value = String(selectedRegnum);
}

function applyPremiseByRegnum(regnum) {
  const warn = document.getElementById("premiseWarn");
  const info = document.getElementById("premiseInfo");

  if (!regnum) {
    document.getElementById("na_regnum").value = "";
    if (warn) warn.style.display = "block";
    if (info) info.style.display = "none";
    refreshDebtTransferBox();
    return;
  }

  document.getElementById("na_regnum").value = regnum;

  const p = window.AbonentsDB?.premises?.[regnum] || null;
  if (!p) {
    if (warn) warn.style.display = "block";
    if (info) info.style.display = "none";
    return;
  }

  document.getElementById("na_city").value = String(p.city || "");
  document.getElementById("na_street").value = String(p.street || "");
  document.getElementById("na_house").value = String(p.house || "");
  document.getElementById("na_flat").value = String(p.flat || "");
  document.getElementById("na_square").value = (p.square === undefined || p.square === null) ? "" : String(p.square);

  const addr = [p.city, p.street, p.house, p.flat].filter(Boolean).join(", ");
  const el = document.getElementById("premiseAddr");
  if (el) el.textContent = addr || "(адрес не заполнен)";
  if (info) info.style.display = "block";
  if (warn) warn.style.display = "none";

  const df = document.getElementById("na_date_from");
  if (df && !df.value) df.value = getDefaultCalcStartDate();

  refreshDebtTransferBox();
}

/* =========================
   ВОЗВРАТ НА ИМПОРТ
   ========================= */
function safeReturnUrl(u){
  const s = String(u || "").trim();
  if (!s) return "";
  if (s.includes("://")) return "";
  if (s.startsWith("//")) return "";
  if (!/^[a-z0-9_\-\/\.]+\.html(\?.*)?$/i.test(s)) return "";
  return s;
}
function goBackToImport(){
  location.href = 'import_xls.html#resume=1';
}

/* =========================
   LINKS HELPERS + ДОЛГ
   ========================= */
function activeLinkForRegnumLocal(db, regnum){
  if (typeof window.activeLinkForRegnum === 'function') return window.activeLinkForRegnum(db, regnum);
  const r = String(regnum || '').trim();
  return (db && Array.isArray(db.links) ? db.links : []).find(l => String(l?.regnum || '').trim()===r && !String(l?.dateTo || '').trim()) || null;
}
function findAbonentByLinkId(db, abonentId){
  const id = String(abonentId || '').trim();
  if (!id) return null;
  if (db.abonents[id]) return { id:id, abonent:db.abonents[id] };
  const keys = Object.keys(db.abonents || {});
  for (let i=0;i<keys.length;i++){
    const k = keys[i], a = db.abonents[k];
    if (a && String(a.uid || '').trim() === id) return { id:k, abonent:a };
  }
  return null;
}
function getAbonentDebtAmount(a){
  if (!a) return 0;
  const cands = [a.totalDebt, a.total_debt, a.mainDebtTotal, a.debtTotal];
  for (let i=0;i<cands.length;i++){
    const n = Number(cands[i]);
    if (Number.isFinite(n)) return Math.max(0, Math.round(n*100)/100);
  }
  return 0;
}
function r2(n){
  const x = Number(n);
  if (!Number.isFinite(x)) return 0;
  return Math.round(x * 100) / 100;
}

/* =========================
   ПЕРЕДАЧА КВАРТИРЫ (CANON)
   ========================= */
let __jkhTransferConfirmed = false;
let __transferCtx = null; // { regnum, oldId, oldFio, oldDebtSnapshot, oldLink }

function __getDebtSnapshotByCalc(oldId, asOfIso){
  try{
    if (!window.JKHCalcEngine || typeof window.JKHCalcEngine.calcTotalsAsOfAdjusted !== 'function') return null;
    const rows = loadPaymentsForLs(String(oldId));
    const d = new Date(String(asOfIso) + "T12:00:00");
    const tot = window.JKHCalcEngine.calcTotalsAsOfAdjusted(rows, d, {
      abonentId: String(oldId),
      applyAdvanceOffset: true,
      allowNegativePrincipal: false
    });
    const p = Number(tot?.principal);
    return Number.isFinite(p) ? p : null;
  }catch(e){ return null; }
}

function __updateNewDebtStartPreview(){
  const el = document.getElementById('newDebtStart');
  if (!el) return;
  const checked = !!document.getElementById('na_transfer_debt')?.checked;
  const snap = r2(__transferCtx?.oldDebtSnapshot || 0);
  el.textContent = (checked ? snap : 0).toFixed(2);
}


/* перенос долга (опционально) */
function hasDebtTransferDuplicate(db, regnum, oldId, newId){
  try{
    const arr = Array.isArray(db.adjustments) ? db.adjustments : [];
    const r = String(regnum||'').trim();
    const o = String(oldId||'').trim();
    const n = String(newId||'').trim();
    return arr.some(x =>
      String(x?.reason||'').includes('Перенос задолженности') &&
      String(x?.regnum||'').trim()===r &&
      String(x?.from||'').trim()===o &&
      String(x?.to||'').trim()===n
    );
  }catch(e){ return false; }
}
function applyDebtTransfer(db, regnum, oldId, newId, amount, dateIso){
  const a = Math.max(0, r2(amount));
  if (!(a>0)) return { ok:true, skipped:true, reason:'zero' };
  if (!Array.isArray(db.adjustments)) db.adjustments = [];
  if (hasDebtTransferDuplicate(db, regnum, oldId, newId)) return { ok:true, skipped:true, reason:'dup' };

  db.adjustments.push({
    regnum: String(regnum||'').trim(),
    from: String(oldId||'').trim(),
    to: String(newId||'').trim(),
    amount: a,
    date: String(dateIso||getTodayIso()),
    reason: 'Перенос задолженности при передаче квартиры'
  });

  try{
    const oldA = db.abonents && db.abonents[oldId];
    const newA = db.abonents && db.abonents[newId];
    if (oldA){
      if (Number.isFinite(Number(oldA.totalDebt))) oldA.totalDebt = Math.max(0, r2(Number(oldA.totalDebt) - a));
      if (Number.isFinite(Number(oldA.mainDebtTotal))) oldA.mainDebtTotal = Math.max(0, r2(Number(oldA.mainDebtTotal) - a));
    }
    if (newA){
      if (!Number.isFinite(Number(newA.totalDebt))) newA.totalDebt = 0;
      if (!Number.isFinite(Number(newA.mainDebtTotal))) newA.mainDebtTotal = 0;
      newA.totalDebt = r2(Number(newA.totalDebt) + a);
      newA.mainDebtTotal = r2(Number(newA.mainDebtTotal) + a);
    }
  }catch(e){}

  return { ok:true, skipped:false, reason:'ok' };
}

/* главное: закрыть период старого и “заморозить” начисления */
function closeOldResponsibilityAndFreeze(db, oldId, closeToIso){
  try{
    const oldA = db.abonents?.[oldId];
    if (!oldA) return false;

    // ставим конец расчёта = дата закрытия ответственности
    oldA.calcEndDate = String(closeToIso || '').trim();

    // фиксируем снапшот долга (для карточки/истории)
    const snap = getAbonentDebtAmount(oldA);
    oldA.lastDebtSnapshot = r2(snap);
    oldA.lastDebtSnapshotDate = String(closeToIso || '').trim();

    // пометка (не обязательно, но удобно)
    if (!oldA.history) oldA.history = [];
    oldA.history.push({
      type: "responsibility_closed",
      date: String(getTodayIso()),
      closeTo: String(closeToIso || '').trim(),
      note: "Период ответственности закрыт при передаче квартиры"
    });

    return true;
  }catch(e){ return false; }
}

function refreshDebtTransferBox(){
  __jkhTransferConfirmed = false;
  __transferCtx = null;

  const box = document.getElementById('debtTransferBox');
  const info = document.getElementById('debtTransferInfo');
  if (!box || !info) return;

  const db = window.AbonentsDB;
  const regnum = String(document.getElementById('na_regnum')?.value || '').trim();
  if (!db || !regnum){ box.style.display='none'; return; }

  const active = activeLinkForRegnumLocal(db, regnum);
  if (!active){ box.style.display='none'; return; }

  const oldObj = findAbonentByLinkId(db, active.abonentId);
  const oldA = oldObj && oldObj.abonent;
  if (!oldA){ box.style.display='none'; return; }

  const df0 = String(document.getElementById('na_date_from')?.value || '').trim() || getDefaultCalcStartDate();
  const closeTo0 = getYesterdayIso(df0);

  const oldId = String(oldObj.id || '').trim();
  // сначала пробуем рассчитать долг по таблице payments_<ЛС> через calc_engine.js (если подключён)
  let debtCalc = __getDebtSnapshotByCalc(oldId, closeTo0);
  const debt = (debtCalc !== null) ? debtCalc : getAbonentDebtAmount(oldA);

  const oldFio = String(oldA.fio || oldId).trim();

  __transferCtx = {
    regnum,
    oldId,
    oldFio,
    oldDebtSnapshot: r2(debt),
    oldLink: active
  };

  info.textContent = 'Текущий ответственный: ' + oldFio;
  /* UI: сумма долга нового на старте зависит от галочки */
  try { __updateNewDebtStartPreview(); } catch(e) {}

  // превью дат передачи
  document.getElementById('transferStartPreview').textContent = df0;
  document.getElementById('transferEndPreview').textContent = closeTo0;

  box.style.display = 'block';
}

/* =========================
   DRAFT (import)
   ========================= */
function loadDraftNewAbonent(){
  if (!window.JKHStore || !JKHStore.getJSON) return null;
  try{ return JKHStore.getJSON('draft_new_abonent_v1', null, null); }catch(e){ return null; }
}
function clearDraftNewAbonent(){
  if (!window.JKHStore || !JKHStore.setJSON) return;
  try{ JKHStore.setJSON('draft_new_abonent_v1', null, null); }catch(e){}
}

/* =========================
   ИМПОРТ ОПЛАТ (как было)
   ========================= */
function paymentsKeyForLs(ls){
  return 'payments_' + String(ls || '').trim();
}
function loadPaymentsForLs(ls){
  try {
    const raw = localStorage.getItem(paymentsKeyForLs(ls));
    if (!raw) return [];
    const arr = JSON.parse(raw);
    return Array.isArray(arr) ? arr : [];
  } catch {
    return [];
  }
}
function savePaymentsForLs(ls, arr){
  try {
    localStorage.setItem(paymentsKeyForLs(ls), JSON.stringify(Array.isArray(arr) ? arr : []));
  } catch (e){
    console.warn('[new_abonent] savePaymentsForLs error', e);
  }
}
function nextPaymentIdForArray(arr){
  let maxId = 0;
  for (const r of (arr || [])){
    const id = Number(r?.id) || 0;
    if (id > maxId) maxId = id;
  }
  return maxId + 1;
}
function paymentsHasDuplicate(arr, iso, amount){
  const a = r2(amount);
  const d = String(iso || '').trim();
  return (arr || []).some(r => r2(r?.paid) === a && String(r?.paid_date || '').trim() === d);
}
function debtsHasDuplicate(debtsArr, dmy, amount){
  const a = r2(amount);
  const dd = String(dmy || '').trim();
  return (debtsArr || []).some(r => r2(r?.paid) === a && String(r?.payDate || '').trim() === dd);
}
function loadImportDraft(){
  try {
    const raw = localStorage.getItem('import_preview_v1');
    if (!raw) return null;
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
function findDraftRowByLs(draft, ls){
  if (!draft || !Array.isArray(draft.rows)) return null;
  const key = String(ls || '').trim();
  return draft.rows.find(r => String(r?.ls || '').trim() === key) || null;
}
function importPaymentsFromDraftForNewAbonent(ls, abonentObj){
  const draft = loadImportDraft();
  const row = findDraftRowByLs(draft, ls);
  if (!row) return { ok: true, imported: 0, reason: 'no_draft_row' };

  const pays = Array.isArray(row.payments) ? row.payments : [];
  if (!pays.length) return { ok: true, imported: 0, reason: 'no_payments' };

  const payArr = loadPaymentsForLs(ls);
  let idCounter = nextPaymentIdForArray(payArr);
  let addedPays = 0;

  for (const p of pays){
    const iso = String(p?.iso || '').trim();
    const amount = r2(p?.amount);
    if (!(amount > 0) || !iso) continue;
    if (paymentsHasDuplicate(payArr, iso, amount)) continue;

    const mm = iso.slice(5,7) || '01';
    const yy = iso.slice(0,4) || String(new Date().getFullYear());

    payArr.push({
      id: idCounter++,
      month: mm,
      year: yy,
      accrued: 0,
      paid: amount,
      paid_date: iso,
      use_period: false,
      period_from_m: mm,
      period_from_y: yy,
      period_to_m: mm,
      period_to_y: yy,
      period_from: `${mm}.${yy}`,
      period_to: `${mm}.${yy}`,
      note: '',
      pay_main: 0,
      pay_penalty: 0,
      total_debt: 0
    });
    addedPays++;
  }

  if (addedPays) savePaymentsForLs(ls, payArr);

  try {
    if (abonentObj){
      if (!Array.isArray(abonentObj.debts)) abonentObj.debts = [];
      for (const p of pays){
        const dmy = String(p?.dmy || '').trim();
        const iso = String(p?.iso || '').trim();
        const amount = r2(p?.amount);
        if (!(amount > 0) || !dmy || !iso) continue;
        if (debtsHasDuplicate(abonentObj.debts, dmy, amount)) continue;
        const year = Number(iso.slice(0,4)) || new Date().getFullYear();
        const monthName = String(p?.monthName || '').trim() || '';
        abonentObj.debts.push({
          year: year,
          month: monthName,
          accrued: 0,
          paid: amount,
          payDate: dmy,
          paymentPeriod: monthName ? `${monthName} ${year}` : String(year),
          penalty: 0,
          mainDebt: 0,
          debtPenalty: 0
        });
      }
    }
  } catch (e){
    console.warn('[new_abonent] debts append error', e);
  }

  return { ok: true, imported: addedPays, reason: 'ok' };
}

/* =========================
   ПРЕДЗАПОЛНЕНИЕ ИЗ QUERY
   ========================= */
function prefillFromQueryParams() {
  let regnum = "";
  let last = "", first = "", mid = "";
  let ls = "", square = "", uid = "";
  let src = "";
  let ret = "";

  try {
    const params = new URLSearchParams(window.location.search || "");
    regnum = (params.get("regnum") || "").trim();
    last = (params.get("last") || "").trim();
    first = (params.get("first") || "").trim();
    mid = (params.get("mid") || "").trim();
    ls = (params.get("ls") || "").trim();
    square = (params.get("square") || "").trim();
    uid = (params.get("uid") || "").trim();
    src = (params.get("src") || "").trim();
    ret = (params.get("return") || "").trim();
  } catch {}

  if (String(new URLSearchParams(window.location.search || '').get('from') || '').trim() === 'import') {
    src = 'import_xls';
  }

  const draft = loadDraftNewAbonent();
  if (draft) {
    last = String(draft.fam || last || '').trim();
    first = String(draft.name || first || '').trim();
    mid = String(draft.otch || mid || '').trim();
    ls = String(draft.ls || ls || '').trim();
    square = String(draft.square || square || '').trim();
    regnum = String(draft.regnum || regnum || '').trim();
    src = 'import_xls';
  }

  document.getElementById("na_src").value = src;
  document.getElementById("na_return").value = ret;

  if (last) document.getElementById("na_last").value = last;
  if (first) document.getElementById("na_first").value = first;
  if (mid) document.getElementById("na_mid").value = mid;
  if (ls) document.getElementById("na_ls").value = normalizeLs4(ls);

  if (square) {
    document.getElementById("na_square_excel").value = square;
    document.getElementById("na_square").value = square;
  }
  if (uid) document.getElementById("na_uid_import").value = uid;

  if (src === "import_xls" || safeReturnUrl(ret)) {
    const ta = document.getElementById("topActions");
    if (ta) ta.style.display = "flex";
  }

  if (src === 'import_xls') {
    const box = document.getElementById('importPrefillBox');
    const txt = document.getElementById('importPrefillText');
    if (box && txt) {
      const fioLine = [last, first, mid].filter(Boolean).join(' ').trim();
      const parts = [];
      if (fioLine) parts.push('ФИО: ' + fioLine);
      if (ls) parts.push('ЛС: ' + normalizeLs4(ls));
      if (square) parts.push('Площадь: ' + square);
      if (regnum) parts.push('regnum: ' + regnum);
      box.style.display = 'block';
      txt.textContent = parts.join(' | ');
    }
  }

  populatePremiseSelect(regnum);
  applyPremiseByRegnum(regnum);

  const df = document.getElementById("na_date_from");
  if (df && !df.value) df.value = getDefaultCalcStartDate();

  refreshDebtTransferBox();
}

/* =========================
   СОЗДАНИЕ АБОНЕНТА (с поддержкой передачи)
   ========================= */
function createAbonent() {
  try{
    if (typeof window.canWriteOrExplain === "function" && !window.canWriteOrExplain()) return;
  }catch(e){}

  const last = document.getElementById("na_last").value.trim();
  const first = document.getElementById("na_first").value.trim();
  const mid = document.getElementById("na_mid").value.trim();
  const fio = joinFio(last, first, mid);
  if (!last || !first) { alert("Заполните Фамилию и Имя"); return; }

  const dbRoot = window.AbonentsDB;
  if (!dbRoot || !dbRoot.abonents) { alert("База AbonentsDB не найдена"); return; }

  const regnum = String(document.getElementById("na_regnum").value || "").trim();
  if (!regnum) { alert("Квартира не выбрана. Выберите квартиру из списка."); return; }

  const premise = dbRoot.premises?.[regnum] || null;
  if (!premise) { alert("Квартира (premises) по regnum не найдена. Сначала заведите квартиру, затем создавайте абонента."); return; }

  const city = String(document.getElementById("na_city").value || "").trim();
  const street = String(document.getElementById("na_street").value || "").trim();
  const house = String(document.getElementById("na_house").value || "").trim();
  const flat = String(document.getElementById("na_flat").value || "").trim();

  const squareRaw = String(document.getElementById("na_square").value || "").trim();
  const square = squareRaw === "" ? "" : Number(squareRaw);

  const phone = document.getElementById("na_phone").value.trim();
  const email = document.getElementById("na_email").value.trim();
  const note = document.getElementById("na_note").value.trim();

  const lsInput = document.getElementById("na_ls").value.trim();
  const ls = getNextLsId(lsInput);

  const dfRaw = document.getElementById('na_date_from')?.value || '';
  const df = String(dfRaw).trim();
  const dateFrom = df || getDefaultCalcStartDate();
  const today = getTodayIso();
  const respStart = String(dateFrom || "").trim() || today;

  if (!Array.isArray(dbRoot.links)) dbRoot.links = [];
  const prevActive = activeLinkForRegnumLocal(dbRoot, regnum);

  // если квартира занята — требуем явную передачу кнопкой
  if (prevActive && String(prevActive.abonentId || '').trim() && String(prevActive.abonentId || '').trim() !== String(ls).trim()){
    if (!__jkhTransferConfirmed){
      alert('Квартира уже занята. Чтобы правильно закрыть старого владельца и создать нового, используйте кнопку «ПЕРЕДАТЬ КВАРТИРУ и СОЗДАТЬ АБОНЕНТА».');
      return;
    }
  }

  // UID
  const uidImport = String(document.getElementById("na_uid_import").value || "").trim();
  const uid = (uidImport && uidImport.startsWith("uid_")) ? uidImport : generateUid();

  // создаём нового с нулевым долгом (как и было)
  dbRoot.abonents[ls] = {
    fio,
    regnum,
    city, street, house, flat,
    square,

    rooms: "",
    share: "",

    phone,
    email,

    debts: [],
    mainDebtTotal: 0,
    penaltyTotal: 0,
    totalDebt: 0,

    defaultNote: note,
    defaultExcludes: [],

    uid: uid,

    calcStartDate: respStart,
    calcEndDate: "",

    calcDate: "",
    stateDate: "",
    docDate: ""
  };

  // ====== если была передача — закрываем старого и фиксируем его долг ======
  let transferMeta = null;
  if (prevActive && __jkhTransferConfirmed && __transferCtx && __transferCtx.oldId){
    const closeTo = getYesterdayIso(respStart);

    // 1) закрыть link старого
    prevActive.dateTo = closeTo;

    // 2) “заморозить” старого (чтобы авто-начисления дальше не шли)
    closeOldResponsibilityAndFreeze(dbRoot, __transferCtx.oldId, closeTo);

    // 3) мета для карточки нового (покажем рядом с “передача долга” в abonent_card.html следующим патчем)
    transferMeta = {
      type: "premise_transfer",
      regnum: regnum,
      fromAbonentId: String(__transferCtx.oldId),
      fromFio: String(__transferCtx.oldFio || ''),
      oldDebtSnapshot: r2(__transferCtx.oldDebtSnapshot || 0),
      newRespFrom: String(respStart),
      oldRespTo: String(closeTo),
      transferDebtApplied: false,
      createdAt: String(today)
    };
  }

  // 4) новый link
  dbRoot.links.push({
    abonentId: String(ls),
    regnum,
    dateFrom: respStart,
    dateTo: ""
  });

  // 5) перенос долга — только если явно галочка
  const transferChecked = !!document.getElementById('na_transfer_debt')?.checked;
  if (transferMeta && transferChecked){
    const amount = r2(transferMeta.oldDebtSnapshot || 0);
    if (amount > 0){
      const res = applyDebtTransfer(dbRoot, regnum, transferMeta.fromAbonentId, String(ls), amount, today);
      transferMeta.transferDebtApplied = !!(res && res.ok && !res.skipped);
    }
  }

  // сохраняем мету передачи в нового абонента (для карточки)
  if (transferMeta){
    dbRoot.abonents[ls].transferMeta = transferMeta;
  }

  // ✅ если из импорта — переносим оплаты
  const src = String(document.getElementById("na_src").value || "").trim();
  if (src === 'import_xls') {
    try { importPaymentsFromDraftForNewAbonent(String(ls), dbRoot.abonents[ls]); } catch (e) {}
  }

  if (window.saveAbonentsDB) window.saveAbonentsDB();

  // ✅ пересчёт начислений только для нового
  try {
    if (window.JKHAutoAccrual && typeof window.JKHAutoAccrual.recalcForAbonent === 'function') {
      window.JKHAutoAccrual.recalcForAbonent(String(ls));
    }
  } catch (e) {}

  const ret = safeReturnUrl(String(document.getElementById("na_return").value || "").trim());
  if (src === "import_xls" || ret) {
    clearDraftNewAbonent();
    alert("Абонент создан. Возвращаюсь к импорту.");
    goBackToImport();
    return;
  }

  alert("Абонент создан.");
  location.href = "abonent_card.html?abonent=" + encodeURIComponent(ls);
}

/* =========================================================
   Список всех абонентов + фильтры
   ========================================================= */
function getDb(){ return window.AbonentsDB?.abonents || {}; }
function getPremises(){ return window.AbonentsDB?.premises || {}; }
function getLinks(){ return Array.isArray(window.AbonentsDB?.links) ? window.AbonentsDB.links : []; }

function getActiveLinkForAbonent(abonentId, regnum){
  const id = String(abonentId);
  const r = String(regnum || "").trim();
  const links = getLinks().filter(l => String(l?.abonentId) === id && String(l?.regnum || "").trim() === r);
  if (!links.length) return null;
  const active = links.find(l => !String(l?.dateTo || "").trim());
  if (active) return active;
  return links.slice().sort((a,b) => String(b?.dateTo||"").localeCompare(String(a?.dateTo||"")))[0];
}

function buildAbonentRow(id, a){
  const premises = getPremises();
  const regnum = String(a?.premiseRegnum || a?.regnum || "").trim();
  const p = regnum ? (premises[regnum] || null) : null;

  const fio = String(a?.fio || "").trim();

  const addrParts = [
    p?.city ?? a?.city,
    p?.street ?? a?.street,
    p?.house ?? a?.house,
    p?.flat ?? a?.flat
  ].map(x => String(x || "").trim()).filter(Boolean);

  const addr = addrParts.join(", ");

  const link = regnum ? getActiveLinkForAbonent(id, regnum) : null;
  const start = String(a?.calcStartDate || link?.dateFrom || "").trim();

  const df = String(link?.dateFrom || "").trim();
  const dt = String(link?.dateTo || "").trim();

  let periodText = "—";
  let periodHtml = "—";
  if (df || dt){
    const isActive = !dt;
    const right = dt ? `<span class="period-ended">${esc(dt)}</span>` : "по настоящее время";
    periodHtml = `${esc(df || "—")} — ${right}`;
    periodText = `${df || "—"} — ${dt || "по настоящее время"}`;
    if (isActive) periodHtml = `<span class="period-active">${periodHtml}</span>`;
  }

  return { id: String(id), fio, addr, start, periodText, periodHtml };
}

let __abonentsCache = [];

function renderAbonentsTable(list){
  const tbody = document.getElementById("abonentsTbody");
  if (!tbody) return;
  tbody.innerHTML = "";

  list.forEach(x => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="mono">${esc(x.id)}</td>
      <td title="${esc(x.fio)}">${esc(x.fio || "—")}</td>
      <td title="${esc(x.addr)}">${esc(x.addr || "—")}</td>
      <td class="mono">${esc(x.start || "—")}</td>
      <td title="${esc(x.periodText)}">${x.periodHtml}</td>
      <td style="text-align:center;">
        <a class="open-link" href="abonent_card.html?abonent=${encodeURIComponent(x.id)}">открыть</a>
      </td>
    `;
    tbody.appendChild(tr);
  });

  const cnt = document.getElementById("abonentsCount");
  if (cnt) cnt.textContent = `Показано: ${list.length} / ${__abonentsCache.length}`;
}

function readFilters(){
  const els = Array.from(document.querySelectorAll(".filter-input"));
  const out = {};
  els.forEach(el => {
    const k = el.getAttribute("data-col");
    out[k] = String(el.value || "").trim().toLowerCase();
  });
  return out;
}

function applyFilters(){
  const f = readFilters();
  const filtered = __abonentsCache.filter(x => {
    const okLs = !f.ls || String(x.id).toLowerCase().includes(f.ls);
    const okFio = !f.fio || String(x.fio).toLowerCase().includes(f.fio);
    const okAddr = !f.addr || String(x.addr).toLowerCase().includes(f.addr);
    const okStart = !f.start || String(x.start).toLowerCase().includes(f.start);
    const okPeriod = !f.period || String(x.periodText).toLowerCase().includes(f.period);
    return okLs && okFio && okAddr && okStart && okPeriod;
  });
  renderAbonentsTable(filtered);
}

function initAbonentsList(){
  const db = getDb();
  const ids = Object.keys(db).sort((a,b) => {
    const na = Number(a), nb = Number(b);
    if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
    return String(a).localeCompare(String(b), "ru");
  });

  __abonentsCache = ids.map(id => buildAbonentRow(id, db[id]));
  renderAbonentsTable(__abonentsCache);

  document.querySelectorAll(".filter-input").forEach(el => el.addEventListener("input", applyFilters));
  document.getElementById("btnFiltersReset")?.addEventListener("click", () => {
    document.querySelectorAll(".filter-input").forEach(i => i.value = "");
    applyFilters();
  });
}

/* =========================
   INIT
   ========================= */
document.addEventListener("DOMContentLoaded", () => {
  try {
    const cb = document.getElementById('na_transfer_debt');
    if (cb) cb.addEventListener('change', __updateNewDebtStartPreview);
  } catch(e) {}

  prefillFromQueryParams();

  document.getElementById("btnBackToImport")?.addEventListener("click", goBackToImport);

  const ps = document.getElementById("premiseSelect");
  if (ps) {
    ps.addEventListener("change", () => {
      const reg = String(ps.value || "").trim();
      applyPremiseByRegnum(reg);
    });
  }

  // обновлять превью дат передачи при изменении даты
  document.getElementById("na_date_from")?.addEventListener("change", refreshDebtTransferBox);

  document.getElementById("na_ls")?.addEventListener("blur", (e) => {
    e.target.value = normalizeLs4(e.target.value);
  });

  document.getElementById("btnCreate").addEventListener("click", createAbonent);

  document.getElementById('btnTransferAndCreate')?.addEventListener('click', () => {
    __jkhTransferConfirmed = true;
    createAbonent();
  });

  initAbonentsList();
});
</script>

<script>closeLayout();</script>
</body>
</html>
